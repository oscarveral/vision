\documentclass{beamer}

\usetheme{Berlin}
\usecolortheme{crane}

% Custom yellow color scheme
\definecolor{UMYellow}{RGB}{255,193,7}
\definecolor{UMDarkYellow}{RGB}{245,166,35}
\definecolor{UMGold}{RGB}{255,179,0}

\setbeamercolor{structure}{fg=UMDarkYellow}
\setbeamercolor{palette primary}{bg=UMYellow,fg=black}
\setbeamercolor{palette secondary}{bg=UMDarkYellow,fg=white}
\setbeamercolor{palette tertiary}{bg=UMGold,fg=black}
\setbeamercolor{palette quaternary}{bg=UMDarkYellow,fg=white}
\setbeamercolor{titlelike}{parent=palette primary}
\setbeamercolor{block title}{bg=UMYellow,fg=black}
\setbeamercolor{block body}{bg=UMYellow!10,fg=black}
\setbeamercolor{frametitle}{bg=UMDarkYellow,fg=white}

% Remove navigation symbols and headline (progress bar)
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{headline}{}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{subcaption}

\title{Visión Artificial}
\subtitle{BT1 y BT2}
\author[Gallego \& Vera]{Juan Diego Gallego Nicolás \\ Óscar Vera López}
\date{\today}
\institute{Universidad de Murcia}

\begin{document}

\frame{\titlepage}

\begin{frame}{Contenido}
  \tableofcontents
\end{frame}

\section{BT1: Procesamiento de Imagen Básico}
\subsection{Dataset}

\begin{frame}{Dataset: Zenseact Frames (ZOD)}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Características:}
    \begin{itemize}
      \item 100.000 imágenes etiquetadas
      \item Cámaras frontales de vehículos
      \item Diversas condiciones de iluminación
      \item 14 países de la UE
      \item Sensores adicionales: LiDAR, radar
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/dataset_grid.png}
      \caption{Muestra del dataset}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Regiones de Interés (ROIs)}
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/rois_visualization.png}
    \caption{Visualización de ROIs con señales de tráfico detectadas}
  \end{figure}
\end{frame}

\subsection{Procesamiento de Imágenes}

\subsubsection{Corrección de Distorsión}

\begin{frame}{Corrección de Distorsión Ojo de Pez}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Algoritmo Kannala-Brandt:}
    \begin{itemize}
      \item Utiliza parámetros de calibración
      \item Mapeo de píxeles distorsionados
      \item Implementado en C
      \item Complejidad: $O(nm)$
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/distortion_correction.png}
      \caption{Antes y después de la corrección}
    \end{figure}
  \end{columns}
\end{frame}

\subsubsection{Filtros Básicos}

\begin{frame}{Filtro de Escala de Grises}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Características:}
    \begin{itemize}
      \item Conversión RGB a luminancia
      \item Implementación en C
      \item Complejidad: $O(nm)$
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/grayscale_filter.png}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Filtro de Umbralización}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Características:}
    \begin{itemize}
      \item Conversión a imagen binaria
      \item Píxeles $\ge$ umbral $\rightarrow$ blanco (255)
      \item Píxeles $\leq$ umbral $\rightarrow$ negro (0)
      \item Implementación en C
      \item Complejidad: $O(nm)$
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/threshold_filter.png}
    \end{figure}
  \end{columns}
\end{frame}

\subsubsection{Filtros de Suavizado}

\begin{frame}{Filtro de Caja (Box Filter)}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Características:}
    \begin{itemize}
      \item Promedio simple de vecindario
      \item Implementación en C
      \item Optimización con sumas parciales
      \item Complejidad: $O(nm)$
      \item Kernel de tamaño impar
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/box_filter.png}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Filtro Gaussiano}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Características:}
    \begin{itemize}
      \item Peso gaussiano en vecindario
      \item Preserva bordes mejor que Box
      \item Implementación en C
      \item Usa propiedad de separabilidad
      \item Tamaño de kernel: $k=6\sigma+1$ (impar)
      \item Complejidad: $O(nm \times (6\sigma+1))$
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/gaussian_filter.png}
    \end{figure}
  \end{columns}
\end{frame}

\subsubsection{Detección de Bordes}

\subsubsection{Detección de Bordes}

\begin{frame}{Filtro de Canny}
    \textbf{Pasos del algoritmo:}
    \begin{itemize}
      \item Reducción de ruido
      \item Detección de gradientes
      \item Supresión de no-máximos
      \item Umbralización histéresis
    \end{itemize}
    
    \vspace{0.5cm}
    \textbf{Implementación en C}
\end{frame}

\begin{frame}{Resultado: Filtro de Canny}
  \begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{figures/canny_filter.png}
    \caption{Bordes detectados con el filtro de Canny}
  \end{figure}
\end{frame}

\subsubsection{Filtros Avanzados}

\begin{frame}{Congruencia de Fase}
    \textbf{Características:}
    \begin{itemize}
      \item Basado en transformada de Fourier
      \item Analiza fase en lugar de amplitud
      \item Resalta bordes débiles
      \item Implementaciones en C y Python
      \item Detecta características importantes no evidentes en el dominio espacial
    \end{itemize}
\end{frame}

\begin{frame}{Resultado: Congruencia de Fase}
  \begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{figures/phase_congruency_filter.png}
    \caption{Detección de bordes con congruencia de fase}
  \end{figure}
\end{frame}

\begin{frame}{Congruencia de Fase + Umbralización}
  \begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{figures/phase_congruency_thresholded.png}
    \caption{Bordes detectados con congruencia de fase y umbralización}
  \end{figure}
\end{frame}

\begin{frame}{Umbralización de Otsu}
    \textbf{Método de Otsu:}
    \begin{itemize}
      \item Umbralización automática
      \item Minimiza varianza intra-clase
      \item Determina umbral óptimo analizando la distribución de niveles de gris
      \item No requiere parámetros manuales
      \item Implementación con OpenCV
    \end{itemize}
\end{frame}

\begin{frame}{Resultado: Umbralización de Otsu}
  \begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{figures/otsu_threshold.png}
    \caption{Imagen umbralizada con el método de Otsu}
  \end{figure}
\end{frame}

\begin{frame}{CLAHE: Contrast Limited Adaptive Histogram Equalization}
    \textbf{Ventajas:}
    \begin{itemize}
      \item Mejora contraste localmente
      \item Divide imagen en pequeñas regiones (tiles)
      \item Aplica ecualización de histograma a cada región independientemente
      \item Limita amplificación de ruido (Contrast Limited)
      \item Mejor que ecualización global
      \item Implementación con OpenCV
    \end{itemize}
\end{frame}

\begin{frame}{Resultado: CLAHE en Color}
  \begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{figures/clahe_color.png}
    \caption{Mejora de contraste con CLAHE en imagen a color}
  \end{figure}
\end{frame}

\begin{frame}{CLAHE en Escala de Grises}
  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{figures/clahe_grayscale_comparison.png}
    \caption{Comparación: original vs. CLAHE en escala de grises}
  \end{figure}
\end{frame}

\subsection{Análisis y Combinaciones}

\begin{frame}{CLAHE + Otsu}
  \begin{figure}
    \centering
    \includegraphics[width=0.85\textwidth]{figures/clahe_otsu_comparison_grid.png}
    \caption{Mejora en la distinción de elementos con CLAHE antes de Otsu}
  \end{figure}
\end{frame}

\begin{frame}{Combinaciones con Canny}
  \begin{figure}
    \centering
    \includegraphics[width=0.85\textwidth]{figures/canny_clahe_otsu_comparison_grid.png}
    \caption{Comparación de preprocesados con Canny}
  \end{figure}
  
  \textbf{Conclusión:} CLAHE mejora significativamente la detección de bordes
\end{frame}

\begin{frame}{Congruencia de Fase + CLAHE}
  \begin{figure}
    \centering
    \includegraphics[width=0.75\textwidth]{figures/phase_clahe_comparison_grid.png}
    \caption{CLAHE puede introducir ruido en congruencia de fase}
  \end{figure}
\end{frame}

\begin{frame}{Canny vs. Congruencia de Fase}
  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{figures/phase_vs_canny_comparison.png}
    \caption{Comparación directa entre ambos métodos}
  \end{figure}
  
  \begin{itemize}
    \item \textbf{Congruencia de Fase:} Más detalles finos y bordes débiles
    \item \textbf{Canny + CLAHE + OTSU:} Más robusto y menos sensible al ruido
  \end{itemize}
\end{frame}

\subsection{Benchmarks}

\begin{frame}{Rendimiento: Filtros de Suavizado}
  \begin{figure}
    \centering
    \includegraphics[width=0.85\textwidth]{figures/benchmark_smoothing_filters.png}
    \caption{Comparativa FFI vs. OpenCV}
  \end{figure}
  
  \begin{itemize}
    \item \textbf{Box Filter:} Nuestra implementación hasta 3x más rápida en ciertos casos
    \item \textbf{Gaussian Filter:} OpenCV gana usando transformadas de Fourier
  \end{itemize}
\end{frame}

\section{BT2: Estimación Robusta de Parámetros}

\subsection{Preprocesamiento}

\begin{frame}{Preprocesamiento de Imágenes}
  \textbf{Pipeline aplicado:}
  \begin{enumerate}
    \item Corrección de distorsión Kannala-Brandt
    \item Reescalado por factor 0.5
    \item Filtro de medianas 5x5 para reducir ruido
  \end{enumerate}
  
  \vspace{0.3cm}
  
  \textbf{Resultado:}
  \begin{itemize}
    \item Dimensiones finales: 1924x1084 píxeles
    \item Imágenes optimizadas para detección de features
  \end{itemize}
\end{frame}

\subsection{Detección de Bordes en HSV}

\begin{frame}{Espacio de Color HSV}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{¿Por qué HSV?}
    \begin{itemize}
      \item Hue (Matiz): tipo de color (0-179)
      \item Saturation: intensidad del color
      \item Value: brillo
      \item Señales diseñadas con colores brillantes
      \item Robusto ante cambios de iluminación
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=0.8\textwidth]{figures/hue_img00.jpg}
      \caption{Canal Hue}
    \end{figure}
    \begin{figure}
      \includegraphics[width=0.8\textwidth]{figures/sat_img00.jpg}
      \caption{Canal Saturación}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Métodos de Detección de Bordes}
  \textbf{Método 1: Canny en HSV}
  \begin{itemize}
    \item Ponderación: 0.25H + 0.75S
    \item Suavizado Gaussiano ($\sigma=0.4$)
    \item Canny con umbrales: 150 y 250
  \end{itemize}
  
  \vspace{0.3cm}
  
  \textbf{Método 2: Segmentación por color + dilatación}
  \begin{itemize}
    \item Segmentación: Rojo [165-180, 0-15] y Azul [90-130]
    \item Umbral de saturación: 90
    \item Eliminación de componentes conexas pequeñas
    \item Dilatación circular
  \end{itemize}
  
  \vspace{0.3cm}
  
  \textbf{Conclusión:} Segmentación por color más robusta, especialmente en condiciones nocturnas
\end{frame}

\begin{frame}{Comparación de Métodos}
  \begin{figure}
    \centering
    \begin{subfigure}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/canny_hsv_img00.jpg}
      \caption{Canny HSV}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/seg_dilate_img00.jpg}
      \caption{Segmentación + Dilatación}
    \end{subfigure}
  \end{figure}
\end{frame}

\subsection{RANSAC para Detección de Features}

\begin{frame}{Detección de Rectas con RANSAC}
  \textbf{Algoritmo implementado en C:}
  \begin{enumerate}
    \item Seleccionar 2 puntos aleatorios
    \item Calcular distancia de puntos a la línea
    \item Contar inliers (umbral de distancia)
    \item Repetir y seleccionar mejor línea
    \item Refinar con mínimos cuadrados
  \end{enumerate}
  
  \vspace{0.3cm}
  
  \textbf{Mejora: Ventana deslizante}
  \begin{itemize}
    \item Reduce sensibilidad al ruido
    \item Detecta bordes más pequeños
    \item Menor requisito de inliers
  \end{itemize}
\end{frame}

\begin{frame}{Resultados: Detección de Líneas}
  \begin{figure}
    \centering
    \begin{subfigure}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/lines_image00.jpg}
      \caption{RANSAC básico}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/linesw_image00.jpg}
      \caption{Ventana deslizante}
    \end{subfigure}
  \end{figure}
  
  Ventana deslizante elimina ruido y detecta líneas relevantes
\end{frame}

\begin{frame}{Detección de Segmentos}
  \textbf{Problema:} Rectas cubren toda la imagen innecesariamente
  
  \vspace{0.3cm}
  
  \textbf{Solución: Algoritmo de Kadane adaptado}
  \begin{itemize}
    \item Proyección ortogonal de inliers sobre la recta
    \item Cálculo de densidad de inliers
    \item Identificación de segmento maximal
    \item Complejidad: $O(k)$ con $k$ = número de inliers
  \end{itemize}
  
  \vspace{0.3cm}
  
\end{frame}

\begin{frame}{Detección de Segmentos}  
  \begin{figure}
    \centering
    \includegraphics[width=0.30\textwidth]{figures/segments_image00.jpg}
    \caption{Segmentos detectados}
  \end{figure}
\end{frame}


\begin{frame}{Detección de Circunferencias}
  \textbf{Método RANSAC adaptado:}
  \begin{itemize}
    \item Selección de 3 puntos aleatorios
    \item Proporción mínima de inliers respecto al radio
    \item Acotación de radio mínimo y máximo
    \item $\pi$ discreto $\approx \sqrt{8}$
  \end{itemize}
  
  \begin{figure}
    \centering
    \begin{subfigure}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/circles_img02.jpg}
      \caption{Imagen 2}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/circles_img09.jpg}
      \caption{Imagen 9}
    \end{subfigure}
    \caption{Circunferencias detectadas}
  \end{figure}
  
  \textbf{Limitación:} Sensible a perspectiva (no detecta elipses)
\end{frame}

\begin{frame}{Pipeline Completo BT2}
  \textbf{Proceso integrado:}
  \begin{enumerate}
    \item Preprocesamiento (distorsión, escalado, filtrado)
    \item Detección de bordes por segmentación de color
    \item Detección de líneas (RANSAC con ventana deslizante)
    \item Detección de segmentos (Algoritmo de Kadane)
    \item Detección de circunferencias (RANSAC)
    \item Iteración con criterios relajados
  \end{enumerate}
\end{frame}

\begin{frame}{Resultados Finales}
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/final_result00.jpg}
    \caption{Img 0}
  \end{figure}
\end{frame}

\begin{frame}{Resultados Finales}
  \begin{figure}
    \centering
      \includegraphics[width=\textwidth]{figures/final_result02.jpg}
      \caption{Img 2}
    \end{figure}
\end{frame}

\begin{frame}{Resultados Finales}
  \begin{figure}
    \centering
      \includegraphics[width=\textwidth]{figures/final_result08.jpg}
      \caption{Img 8}
    \end{figure}
\end{frame}


\subsection{Análisis de Rendimiento}

\begin{frame}{Análisis de RANSAC}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Complejidad temporal:} $O(it \times k)$
    \begin{itemize}
      \item $it$: número de iteraciones
      \item $k$: píxeles de borde
      \item Tiempo: $\sim$0.03 $\mu$s/píxel
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/ransacvsedges.png}
      \caption{Tiempo vs píxeles}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Convergencia de RANSAC}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Parámetros:}
    \begin{itemize}
      \item 1500 iteraciones: 95\% éxito
      \item Tiempo: 0.045 ms/recta
      \item Pipeline: $\sim$6 ms
      \item Viable para tiempo real
    \end{itemize}
    
    \column{0.5\textwidth}
    \begin{figure}
      \includegraphics[width=\textwidth]{figures/ramo.png}
      \caption{Tasa de éxito}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Fin}
  
    Muchas gracias!

\end{frame}

\end{document}
